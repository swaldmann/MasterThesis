\section{Concepts}

\subsection{Algorithms}

\subsubsection{DPccp}
One of the algorithms visualized is \texttt{DPccp}, as introduced by Guido Moerkotte and Thomas Neunmann in 2006 \cite{moerkotte2006analysis}.
The algorithm is specified as follows:

\vspace{0.5cm}
\texttt{DPccp}($R = \{R_1, \ldots, R_n\}$)
\begin{algorithm}
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{A connected query graph with relations $R = \{R_0,\ldots,R_{n-1}\}$}
\Output{An optimal bushy join tree}
\BlankLine
\ForEach{$R_i \in R$}{
    BestPlan($\{R_i\}) = R_i$;
}
\ForEach{csg-cmp-pairs $(S_1, S_2), S = S_1 \cup S_2$}{
    ++InnerCounter;\\
    ++OnoLohmanCounter;\\
    $p_1$ = BestPlan($S_1$);\\
    $p_2$ = BestPlan($S_2$);\\
    CurrPlan = CreateJoinTree($p_1$, $p_2$);\\
    \If{cost(BestPlan($S$)) $>$ cost(CurrPlan)}{
        BestPlan(S) = CurrPlan;\\
    }
    CurrPlan = CreateJoinTree($p2$, $p1$);\\
    \If{cost(BestPlan($S$)) $>$ cost(CurrPlan)}{
        BestPlan(S) = CurrPlan;\\
    }
}
CsgCmpPairCounter = 2 * OnoLohmanCounter;\\
\Return{BestPlan(\{$R_0,\ldots ,R_{n-1}\}$)}
\vspace{0.5cm}
\caption{DPccp}
\end{algorithm}

\vspace{0.5cm}
\texttt{EnumerateCsg}
\begin{algorithm}
\SetKwInOut{Input}{Input}
\SetKwInput{kwPrecondition}{Precondition}
\SetKwInOut{Output}{Output}
\Input{A connected query graph $G = (V,E)$}
\kwPrecondition {Nodes in $V$ are numbered according to a breadth-first search}
\Output{Emits all subsets of $V$ including a connected subgraph of $G$}
\BlankLine
\ForEach{$i \in [n-1,\ldots,0]$ descending}{
    \textbf{emit} \{$v_i$\};\\
    EnumerateCsgRec($G, \{v_i\}, \mathcal{B}_i$);\\
}
\vspace{0.5cm}
\caption{EnumerateCsg}
\end{algorithm}

\texttt{EnumerateCsgRec}
\begin{algorithm}
    \BlankLine
    $N = \mathcal{N}(S) \setminus X$;\\
    \ForEach{$S' \subseteq N, S' \neq \emptyset$, enumerate subsets first}{
        \textbf{emit} ($S \cup S'$);\\
    }
    \ForEach{$S' \subseteq N, S' \neq \emptyset$, enumerate subsets first}{
        EnumerateCsgRec($G, (S \cup S'), (X \cup N)$);\\
    }
\vspace{0.5cm}
\caption{EnumerateCsgRec}
\end{algorithm}

\begin{algorithm}
    \SetKwInOut{Input}{Input}
    \SetKwInput{kwPrecondition}{Precondition}
    \SetKwInOut{Output}{Output}
    \Input{A connected query graph $G = (V,E)$, a connected subset $S_1$}
    \kwPrecondition{Nodes in $V$ are numbered according to a breadth-first search}
    \Output{Emits all complements $S_2$ for $S_1$ such that ($S_1$, $S_2$ is a csg-cmp-pair)}
    \BlankLine
    $X = \mathcal{B}_{min(S_1) \cup S_1}$;\\
    $N = \mathcal{N}(S_1)\setminus X$;\\
    \ForEach{$v_i \in N$ by descending $i$}{
        \textbf{emit} \{$v_i$\};\\
        EnumerateCsgRec($G, \{v_i\}, X \cup \mathcal{B}_i(N)$);\\
    }
    \vspace{0.5cm}
    \caption{EnumerateCmp}    
\end{algorithm}

\subsection{Server}

In order for the server not having to memorize client or session information, we want to establish a stateless communications protocol.
Thus, we're conforming to the Representational state transfer (REST) architecture as laid out in \cite{fielding2000architectural}.
The exact API entry points are specified in \ref{sub:api-entry-points}.

\subsubsection{API Specification}
\label{sub:api-entry-points}

\subsection{Client}

\subsubsection{Query Graphs}

Visual representations of query graphs are drawn on a canvas with a top-left origin.
With $n$ we define the number of nodes, $h$ is the height of the canvas, and $w$ its width. 
As restricted by the user interface, we also set the condition that $n \geq 3$.

Additionally, we define $m$ as the margin to the canvas bounds, and $r$ as the radius of a node.
Taking $m$ and $r$ into consideration, the drawable width of the canvas, i.e. a centered layout box inside the canvas with margin $m$, is given by 

\begin{equation}\label{eqn:painting-w_hat}
    \hat{w} = w - 2(m - r)
\end{equation}

and analogously, the drawable height is given by

\begin{equation}\label{eqn:painting-h_hat}
    \hat{h} = h - 2(m - r)    
\end{equation}

\paragraph{Chain} For chain query graphs we draw nodes at the vertical center of the canvas and set an equal spacing in between. Thus, the canvas point ($x_i$, $y_i$) for the node with index $i$ is given by


\begin{equation}
    (x_i, y_i) = (m + r + \frac{i\hat{w}}{n - 1}, \frac{h}{2})
\end{equation}

\paragraph{Star} 
Star query graphs are drawn by placing the node with index $i = 0$ at the canvas' center, and all following nodes in a circle around it, starting at the rightmost vertically centered point ($\theta_0 = 0^{\circ}$).

The radius of this circle is equivalent to %Cycle graph%
and given by 

\begin{equation}\label{eqn:painting-r_star}
    r_{star} = \frac{w}{2} - r - m
\end{equation}

For the current node we define the angle by
\begin{equation}\label{eqn:painting-theta}
    \theta_i = \frac{2i\pi}{n - 1}
\end{equation}

Thus, the point for the node at index $i$ is given by

\begin{equation}
    (x_i, y_i) = 
    \begin{cases}
        (\frac{w}{2}, \frac{h}{2}),& \text{if } i = 0\\
        (r_{star}\cos{\theta_i} + r_{star} + r + m, r_{star}\sin{\theta_i} + r_{star} + r + m), & \text{otherwise}
    \end{cases}
\end{equation}

\paragraph{Tree}

The node position calculation for tree query graphs requires an additional parameter. 
By $k$ we denote the degree of the tree. So far only complete $k$-ary query graphs be drawn.
First, we calculate the vertical position for each given node $i$.

\begin{equation}
    (x_i, y_i) = (i - 2^{\lfloor \log_k(i+1) \rfloor}, r + m + \frac{\hat{w}}{\lfloor \log_kn \rfloor} \lfloor \log_k(i + 1) \rfloor)
\end{equation}

\paragraph{Cycle} 

We define $r_{star}$ the same way as we did in \eqref{eqn:painting-r_star}.
Similarly to \eqref{eqn:painting-theta}, $\theta_i$ is given by

\begin{equation}\label{eqn:painting-theta_cycle}
    \theta_i = \frac{2i\pi}{n}
\end{equation}

Thus, the point for a respective node is given by

\begin{equation}
    (x_i, y_i) = (r_{star}\cos{\theta_i} + r_{star} + r + m, r_{star}\sin{\theta_i} + r_{star} + r + m)
\end{equation}