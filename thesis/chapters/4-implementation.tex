
\section{Implementation}

\subsection{API Requirements and Design Goals}
\label{subsub:api-requirements-goals}
\paragraph{Declarativity} One of the main goals of this framework is to minimize 
the amount of code or configuration that has to be added to exisiting algorithms' implementations in order to make use of the visualization for its intended purpose. The visualization should therefore be specified as declaratively as 
possible, with the user specifying \textit{only} the relevant parameters–while minimizing the amount of required boilerplate code.

This allows for many side-effects like reusability, mainta

\paragraph{Orthogonality}
Most importantly though, the property  of orthogonality 
as defined by Eric S. Raymond in \textit{The Art of Unix
Programming} \cite{raymond2003compactness} has to be fulfilled for the visualization code with regards to the algorithm implementation's code, i.e. it should not change its behavior or state.

More pragmatically, this means that the algorithm has to 
conform to the \texttt{Visualizable} Go type we define as 
follows:

%\begin{figure}[H]
\begin{minted}{go}
    type Visualizable func(QG QueryGraph)
\end{minted}
%\caption{\texttt{Visualizable} type}
%\centering
%\end{figure}

With the separation of the complex algorithm and user interface/visualization logic in mind is to keep the amount code required to create new visualizations as minimal as possible. 
Thus, we organize their architecture in a client-server 
relationship, whereby the client specifies the join 
problem parameters and configuration and the server can
generate a client-interpretable output to work with.

The advantages of this approach are multifold:
\begin{itemize}
    \item The server part and UI part respectively can be
          updated or even completely exchanged without 
          changing the other
    \item More complex join ordering algorithms can be 
          performed on a (more powerful) server
    \item The above allow us to run the application 
          within a web application without sacrificing 
          the performance by limiting ourselves with a 
          slow, interpreting JavaScript engine, but being 
          able to run compiled and thus more optimized 
          code
    \item (Allows us to formally specify interfaces between
          client and server) (Abbildung malen)
\end{itemize}

\paragraph{Flexibility}
The visualization tools should be abstract enough that it is not catered towards a specific algorithm, but can used to visualize a wide range of algorithms, especially ones it has not been explicitly programmed for.  

\paragraph{High signal-to-noise ratio} 
In our implementation we are using code folding, enabled
through the orthogonality property as mentioned in 
section \ref{subsub:api-requirements-goals}. This allows
us to completely show or hide the visualization code 
when required. Thus, we can achieve an inobtrusive
debugging tool that can be written alongisde an 
algorithm's implementation code and doesn't decrease
its signal-to-noise ratio.

\subsection{Choice of Technology}

For the implementation of both client and server code we
want to maximize

\begin{enumerate}[label={(\roman*)}]
    \item \label{itm:accessibility} \textbf{Accessibility}, a minimal amount of effort required to access the application
    \item \label{itm:maintainability} \textbf{Maintainability}, a high degree of technological similarities with related projects 
    \item \label{itm:testedness} \textbf{Tried-and-testedness}, a large user base and well-received reference applications
\end{enumerate}

In order to maximize \ref{itm:accessibility} we create an application that runs in a web browser and doesn't need any user-initiated installation or update procedures.
With the 2017 released WebAssembly (Wasm)\footnote{\url{https://webassembly.org}} portable byte-code standard still being in its infancy at around 90\% browser support\footnote{\url{https://caniuse.com/wasm}} and being recommended by the World Wide Web Consortium not until December 5th 2019\footnote{\url{https://www.w3.org/TR/wasm-core-1/}}, this leaves us with JavaScript as the only viable language for the client-side code. 

Additionally, in order to modularize the user interface and adding the ability to import existing user interface components, we use \texttt{React.js}\footnote{\url{https://reactjs.org}}, as of writing this thesis the most popular JavaScript library for building user interfaces.
%\footnote{Ranked by number of stars on \url{https://github.com/search?l=JavaScript&o=desc&q=language%3AJavaScript&s=stars&type=Repositories}}.
% search?l=Go&o=desc&q=http&s=stars&type=Repositories

For the server code and algorithm implementations we use the Go programming language and \texttt{gin-gonic}\footnote{\url{https://github.com/gin-gonic/gin}}, which at the time of writing this thesis is the most-starred HTTP framework on GitHub\footnote{\url{https://github.com/}}.

%Thus, we resort to modern, but well-adopted languages and libraries.
%The software should be built with technologies that prepare well for continued development and maintenance.

\subsection{Tooling}

\subsubsection{Join Problem Generator}
We represent the join problems in a JSON format as defined in section \ref{subsub:join-problem-data-structure}. 
Some JSON files are taken from the supplementary material to the ``IE 630 Query Optimization'' course exercises at the University of Mannheim\footnote{\url{https://www.wim.uni-mannheim.de/moerkotte/teaching/courses/query-optimization/}}
, which contains examples for join problems with a query type $QT \in $ \{Chain, Clique, Cycle, Star\} and a number of relations $n \in [2,10]$.

Additionally, we create a join problem generator for complete binary trees with a degree $k$ and a number of relations $n$.

\paragraph{Complete Binary Tree}
\subparagraph{Neighbors}
First, we get the number of vertices which have children, i.e. for which neighbor entries exist.
In the case of (binary) trees, when enumerating the relations in a breadth-first manner, this is given by 
\begin{equation}
    n_{withNeighbors} = \lceil\frac{n}{k}\rceil
\end{equation}
Accordingly, we specify the list of neighbors starting with index 0 as
\begin{equation}
   V := \{v_i\}_{i=0}^{n_{withNeighbors}-1}
\end{equation} 

In order to define each element we first need to determine the level $l(v_i)$ of each node $v_i$ in the tree. This is given by
\begin{equation}
    l(v_i) = log_2(i+1)
\end{equation}

We then calculate the count of number of nodes in the levels below $l(v_i)$:
\begin{equation}
     pre_i = \vert \{v_j \in V \vert l(v_j) < l(v_i)\} \vert = 2^{l(v_i) + 1} - 1
\end{equation}

This allows us to calculate the number of children for each level $l(v_i)$.
\begin{equation}
    levelchildren_i = \min(2^{l(v_i) + 1}, n - pre_i)
\end{equation}

Furthermore, we calculate the ``column'' $c_i$ of $v_i$, given by
\begin{equation}
    c_i = i - 2^{l(v_i)} + 1
\end{equation}

This lets us calculate the number of children $nodechildren_i$ for a node at index $i$:
\begin{equation}
    n_{children_i} = \min(k, levelchildren_i - c_i * k)
\end{equation}

Now we can define the neighbors of $v_i$ as
\begin{equation}
    nb_i = \{ x_{i, j} \}_{j=0}^{n_{children_i} - 1} 
\end{equation}

We also calculate the lowest index of the node's neighbors. (TODO: Math).
\begin{equation}
    neighborLowestI = ik + 1
\end{equation}

For each element $x_{i, j} \in nb_i$ we then calculate the offset for its $j$ index.
\begin{equation}
    neighborOffset_j = j \mod{k}
\end{equation}

The index of the neighbor is thus given by
\begin{equation}
    neighborI_j = neighborLowestI + neighborOffset_j
\end{equation}

Finally, we can define $x_{i, j} \in nb_i$ as
\begin{equation}
    x_{i, j} = neighborI_j
\end{equation}

In the implementation, we can then join all neighbors together and add the result to the generated JSON file.
\begin{equation}
    %X_i = {x}
\end{equation}

% We then join all $$
% Joining x_{i, j} into array for each i
\subparagraph{Relations}
Specifying the relations $R$ is trivial. 

\begin{equation}
R := \{r_i\}_{i=0}^{n-1}
\end{equation}
where the cardinality $c_{r_i}$ of each relation $r_i$ is a random variable following uniform distribution over the set $\mathbb{R} \cap [0,10000]$.

\subparagraph{Selectivities}



\subsubsection{Utility Functions}


In order to provide a starting point for the algorithm implementation, we use a modified and extended version of the \url{infra.go} and \url{joinproblemparser.go} file provided for the exercises in the Query Optimization (CS50x) course \texttt{} at the Chair of Practical Computer Science III at the University of Mannheim.

Modifications include:
\paragraph{Simplification of the }

\paragraph{Addition of a PowerSet}
For the implementation of \texttt{DPccp} we need an additional function that returns not just the subsets of an (\texttt{unsigned int} bit vector $S$, but its power set excluding the empty set, $\mathcal P(S)\setminus\{\varnothing\}$.

\begin{minted}{go}
    func PowerSet(S uint) []uint {
        subsets := Subsets(S)
        if len(subsets) == 1 && subsets[0] == S {
            return subsets
        }
        return append(subsets, S)
    }
\end{minted}

\begin{itemize}
    \item Simplification of SetMinus
    \item Chaning join problems and class variable names for linter
\end{itemize}


We add some additional helper functions:
\begin{minted}{go}   
func contains(s []uint, e uint) bool {
    for _, a := range s {
        if a == e {
            return true
        }
    }
    return false
}    
\end{minted}

\subsection{Linting}
The project uses the Go language linter\footnote{\url{https://github.com/golang/lint}} to ensure a common coding and documentation style with what is used at Google, the creators of Go.
All of the supplied files (\texttt{infra.go} and \texttt{joinproblemparser.go} have been modified to satisfy all linter requirements. (TODO: Which ones)

For the client-side code we use ESLint\footnote{\url{https://eslint.org}} configured with the \texttt{"react-app"} template\footnote{\url{https://github.com/facebook/create-react-app/blob/master/.eslintrc.json}}, which itself is an extension of the \texttt{"eslint:recommended"} template as specified on \url{https://eslint.org/docs/rules/}.

\subsection{Building}
As the project makes heavy use of the ECMAScript 2020\footnote{\url{https://www.ecma-international.org/publications/standards/Ecma-262.htm}} syntax, it is transpiled using the Babel cross-compiler\footnote{\url{https://babeljs.io}} to a more downwards-compatible JavaScript version when building the project.

\newpage
\subsection{Data Structures}
\label{sub:data-structures}

\subsubsection{Join Problem}
\label{subsub:join-problem-data-structure}

All join problems can be defined using the following JSON structure. ``JSON'' refers to the JavaScript Object Notation Data Interchange Format as specified in RFC 7159\footnote{\url{https://tools.ietf.org/html/rfc7159}}.
\begin{minted}{json}
[
    {
        problemID: number,
        problemNeighbors: {
            string: string
        },
        problemNumberOfRelations: number,
        problemRelations: [
            relationCardinality: number,
            relationName: string,
            relationPID: number,
            relationRID: number
        ],
        problemSelectivities: {
            string: number
        }
    }
]
\end{minted}
The names of the keys correspond to the explicitly defined keys for the \texttt{JSONJoinProblem} type in the \texttt{joinProblemParser.go} file.

\subsection{Installation and Development}

\subsubsection{Prerequisites}
In order to run the project locally some prerequisites have to be fulfilled:
\begin{itemize}
    \item The Go programming language has to be installed according to the official installation guidelines\footnote{\url{https://golang.org/doc/install}}
    \item The Go development has to be set up correctly, namely specifying the \texttt{\$GOOROOT} and \texttt{\$GOPATH} environment variables
    \item The Node Package Manager (npm) has to be installed along with the Node.js runtime\footnote{\url{https://www.npmjs.com/get-npm}}
\end{itemize}

\subsubsection{Dependencies}
\label{subsub:dependencies}

\paragraph{Client}
Client dependencies are maintained in the \texttt{package.json} file of the project's \texttt{client} directory.
\paragraph{Server}
The server-side code doesn't require any dependencies other than the Go standard libary packages as listed on \url{https://golang.org/pkg/#stdlib}.

\subsubsection{Local Development}
Once dependencies are installed as specified in section \ref{subsub:dependencies}, the project can be run locally by navigating to the project directory in a Unix shell (macOS and Linux) or PowerShell (Windows) and running

\begin{minted}{shell-session}
    $ cd client && npm install && npm start
\end{minted}
and, in another shell instance,
\begin{minted}{shell-session}
    $ cd server && go install && go run main.go
\end{minted}

This will start two locally running web servers that can be accessed via \url{https://localhost:3000/} (Client) and \url{https://localhost:8080/} (Server).


\subsection{Deployment}

a web application–the user does not have to update the application himself. 
The duty of updating the application is on the host's side and happens by deploying either a new version of the server code or the client code to a web server.